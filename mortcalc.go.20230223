package main

import (
	"fmt"
	"html/template"
	"log"
	"net/http"
	"math"
)

const serverPort = 3001

type CalcVariables struct {
	Principal float64    // initial loan
	Interest  float64    // interest rate
	Frequency float64    // daily - 365, weekly - 52, monthly - 12, yearly - 1
	Term      float64    // term in months
}

// Compound method referencing CalcVariables
func (cv CalcVariables) Compound() float64 {
	// A = P(1 + r/n)^nt
	return math.Round((cv.Principal*math.Pow(1+cv.Interest/(100*cv.Frequency), cv.Frequency*cv.Term/12))*100)/100
}

// func getParams() (http.Handler, CalcVariables) {
func getParams() http.Handler {
	gp := func(w http.ResponseWriter, r *http.Request) {
		// t := template.Must(template.ParseFiles("templates/input.html"))

		t, err := template.ParseFiles("templates/input.html")
		if err != nil {
			log.Print("template parsing error: ", err)
		}

		log.Print(r.Method)
		if r.Method != http.MethodPost {
			t.Execute(w, nil)
			return
		}

		log.Print(r.FormValue("principal"))
		// params := CalcVariables{
		// 	Principal:   r.FormValue("principal"),
		// 	Interest:    r.FormValue("interest"),
		// 	Frequency:   r.FormValue("frequency"),
		// 	Term:        r.FormValue("term"),
		// }

		// log.Print(params)

		t.Execute(w, struct{ Success bool }{true})
		// t, err := template.ParseFiles("templates/mortcalc.html")
		// if err != nil {
		// 	log.Print("template parsing error: ", err)
		// }
		// err = t.Execute(w, cv)
		// if err != nil {
		// 	log.Print("template executing error: ", err)
		// }
	}
	return http.HandlerFunc(gp)
}

func showCalc(cv CalcVariables) http.Handler {
	sc := func(w http.ResponseWriter, r *http.Request) {
		t, err := template.ParseFiles("templates/mortcalc.html")
		if err != nil {
			log.Print("template parsing error: ", err)
		}
		err = t.Execute(w, cv)
		if err != nil {
			log.Print("template executing error: ", err)
		}
	}
	return http.HandlerFunc(sc)
}

func showAmount(a float64) http.Handler {
	sa := func(w http.ResponseWriter, r *http.Request) {
		t, err := template.ParseFiles("templates/mortamount.html")
		if err != nil {
			log.Print("template parsing error: ", err)
		}
		err = t.Execute(w, a)
		if err != nil {
			log.Print("template executing error: ", err)
		}
	}
	return http.HandlerFunc(sa)
}

func main() {
	mux := http.NewServeMux()

	// Order of events - would be great to keep this all on one page (nested templates?)
	// 1. Get CalcVariables from user input forms
	// 2. Submit will populate CalcVariables struct
	// 3. Display calculated amount using Compound method of CalcVariables struct
	// 4. Brilliant to be able to show each frequency payment

	MortCalcVars := CalcVariables{
		Principal: 200000,
		Interest: 6,
		Frequency: 365,
		Term: 12,
	}
	log.Print(MortCalcVars.Compound())
	mc := showCalc(MortCalcVars)
	mux.Handle("/calc", mc)
	sa := showAmount(MortCalcVars.Compound())
	mux.Handle("/amount", sa)
	calc := getParams()
	mux.Handle("/", calc)

	log.Print("Listening on :", serverPort)
	http.ListenAndServe(fmt.Sprintf(":%d", serverPort), mux)
}

// REFERENCE: https://www.alexedwards.net/blog/an-introduction-to-handlers-and-servemuxes-in-go
